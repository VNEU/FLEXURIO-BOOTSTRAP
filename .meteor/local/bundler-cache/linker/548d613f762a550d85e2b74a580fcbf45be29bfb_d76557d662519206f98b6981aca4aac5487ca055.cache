[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar CryptoJS = Package['jparker:crypto-core'].CryptoJS;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////\n//                                                                   //\n// packages/jparker_crypto-aes/packages/jparker_crypto-aes.js        //\n//                                                                   //\n///////////////////////////////////////////////////////////////////////\n                                                                     //\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/jparker:crypto-aes/lib/aes.js                                                                              //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/*                                                                                                                     // 1\nCryptoJS v3.1.2                                                                                                        // 2\ncode.google.com/p/crypto-js                                                                                            // 3\n(c) 2009-2013 by Jeff Mott. All rights reserved.                                                                       // 4\ncode.google.com/p/crypto-js/wiki/License                                                                               // 5\n*/                                                                                                                     // 6\n(function () {\r                                                                                                        // 7\n    // Shortcuts\r                                                                                                      // 8\n    var C = CryptoJS;\r                                                                                                 // 9\n    var C_lib = C.lib;\r                                                                                                // 10\n    var BlockCipher = C_lib.BlockCipher;\r                                                                              // 11\n    var C_algo = C.algo;\r                                                                                              // 12\n\r                                                                                                                      // 13\n    // Lookup tables\r                                                                                                  // 14\n    var SBOX = [];\r                                                                                                    // 15\n    var INV_SBOX = [];\r                                                                                                // 16\n    var SUB_MIX_0 = [];\r                                                                                               // 17\n    var SUB_MIX_1 = [];\r                                                                                               // 18\n    var SUB_MIX_2 = [];\r                                                                                               // 19\n    var SUB_MIX_3 = [];\r                                                                                               // 20\n    var INV_SUB_MIX_0 = [];\r                                                                                           // 21\n    var INV_SUB_MIX_1 = [];\r                                                                                           // 22\n    var INV_SUB_MIX_2 = [];\r                                                                                           // 23\n    var INV_SUB_MIX_3 = [];\r                                                                                           // 24\n\r                                                                                                                      // 25\n    // Compute lookup tables\r                                                                                          // 26\n    (function () {\r                                                                                                    // 27\n        // Compute double table\r                                                                                       // 28\n        var d = [];\r                                                                                                   // 29\n        for (var i = 0; i < 256; i++) {\r                                                                               // 30\n            if (i < 128) {\r                                                                                            // 31\n                d[i] = i << 1;\r                                                                                        // 32\n            } else {\r                                                                                                  // 33\n                d[i] = (i << 1) ^ 0x11b;\r                                                                              // 34\n            }\r                                                                                                         // 35\n        }\r                                                                                                             // 36\n\r                                                                                                                      // 37\n        // Walk GF(2^8)\r                                                                                               // 38\n        var x = 0;\r                                                                                                    // 39\n        var xi = 0;\r                                                                                                   // 40\n        for (var i = 0; i < 256; i++) {\r                                                                               // 41\n            // Compute sbox\r                                                                                           // 42\n            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\r                                              // 43\n            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\r                                                                     // 44\n            SBOX[x] = sx;\r                                                                                             // 45\n            INV_SBOX[sx] = x;\r                                                                                         // 46\n\r                                                                                                                      // 47\n            // Compute multiplication\r                                                                                 // 48\n            var x2 = d[x];\r                                                                                            // 49\n            var x4 = d[x2];\r                                                                                           // 50\n            var x8 = d[x4];\r                                                                                           // 51\n\r                                                                                                                      // 52\n            // Compute sub bytes, mix columns tables\r                                                                  // 53\n            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\r                                                               // 54\n            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\r                                                                     // 55\n            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\r                                                                    // 56\n            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\r                                                                    // 57\n            SUB_MIX_3[x] = t;\r                                                                                         // 58\n\r                                                                                                                      // 59\n            // Compute inv sub bytes, inv mix columns tables\r                                                          // 60\n            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\r                               // 61\n            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\r                                                                // 62\n            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\r                                                               // 63\n            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\r                                                               // 64\n            INV_SUB_MIX_3[sx] = t;\r                                                                                    // 65\n\r                                                                                                                      // 66\n            // Compute next counter\r                                                                                   // 67\n            if (!x) {\r                                                                                                 // 68\n                x = xi = 1;\r                                                                                           // 69\n            } else {\r                                                                                                  // 70\n                x = x2 ^ d[d[d[x8 ^ x2]]];\r                                                                            // 71\n                xi ^= d[d[xi]];\r                                                                                       // 72\n            }\r                                                                                                         // 73\n        }\r                                                                                                             // 74\n    }());\r                                                                                                             // 75\n\r                                                                                                                      // 76\n    // Precomputed Rcon lookup\r                                                                                        // 77\n    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\r                                    // 78\n\r                                                                                                                      // 79\n    /**\r                                                                                                               // 80\n     * AES block cipher algorithm.\r                                                                                    // 81\n     */\r                                                                                                               // 82\n    var AES = C_algo.AES = BlockCipher.extend({\r                                                                       // 83\n        _doReset: function () {\r                                                                                       // 84\n            // Shortcuts\r                                                                                              // 85\n            var key = this._key;\r                                                                                      // 86\n            var keyWords = key.words;\r                                                                                 // 87\n            var keySize = key.sigBytes / 4;\r                                                                           // 88\n\r                                                                                                                      // 89\n            // Compute number of rounds\r                                                                               // 90\n            var nRounds = this._nRounds = keySize + 6\r                                                                 // 91\n\r                                                                                                                      // 92\n            // Compute number of key schedule rows\r                                                                    // 93\n            var ksRows = (nRounds + 1) * 4;\r                                                                           // 94\n\r                                                                                                                      // 95\n            // Compute key schedule\r                                                                                   // 96\n            var keySchedule = this._keySchedule = [];\r                                                                 // 97\n            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\r                                                            // 98\n                if (ksRow < keySize) {\r                                                                                // 99\n                    keySchedule[ksRow] = keyWords[ksRow];\r                                                             // 100\n                } else {\r                                                                                              // 101\n                    var t = keySchedule[ksRow - 1];\r                                                                   // 102\n\r                                                                                                                      // 103\n                    if (!(ksRow % keySize)) {\r                                                                         // 104\n                        // Rot word\r                                                                                   // 105\n                        t = (t << 8) | (t >>> 24);\r                                                                    // 106\n\r                                                                                                                      // 107\n                        // Sub word\r                                                                                   // 108\n                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\r\n\r                                                                                                                      // 110\n                        // Mix Rcon\r                                                                                   // 111\n                        t ^= RCON[(ksRow / keySize) | 0] << 24;\r                                                       // 112\n                    } else if (keySize > 6 && ksRow % keySize == 4) {\r                                                 // 113\n                        // Sub word\r                                                                                   // 114\n                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\r\n                    }\r                                                                                                 // 116\n\r                                                                                                                      // 117\n                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\r                                            // 118\n                }\r                                                                                                     // 119\n            }\r                                                                                                         // 120\n\r                                                                                                                      // 121\n            // Compute inv key schedule\r                                                                               // 122\n            var invKeySchedule = this._invKeySchedule = [];\r                                                           // 123\n            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\r                                                   // 124\n                var ksRow = ksRows - invKsRow;\r                                                                        // 125\n\r                                                                                                                      // 126\n                if (invKsRow % 4) {\r                                                                                   // 127\n                    var t = keySchedule[ksRow];\r                                                                       // 128\n                } else {\r                                                                                              // 129\n                    var t = keySchedule[ksRow - 4];\r                                                                   // 130\n                }\r                                                                                                     // 131\n\r                                                                                                                      // 132\n                if (invKsRow < 4 || ksRow <= 4) {\r                                                                     // 133\n                    invKeySchedule[invKsRow] = t;\r                                                                     // 134\n                } else {\r                                                                                              // 135\n                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\r\n                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\r // 137\n                }\r                                                                                                     // 138\n            }\r                                                                                                         // 139\n        },\r                                                                                                            // 140\n\r                                                                                                                      // 141\n        encryptBlock: function (M, offset) {\r                                                                          // 142\n            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\r       // 143\n        },\r                                                                                                            // 144\n\r                                                                                                                      // 145\n        decryptBlock: function (M, offset) {\r                                                                          // 146\n            // Swap 2nd and 4th rows\r                                                                                  // 147\n            var t = M[offset + 1];\r                                                                                    // 148\n            M[offset + 1] = M[offset + 3];\r                                                                            // 149\n            M[offset + 3] = t;\r                                                                                        // 150\n\r                                                                                                                      // 151\n            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\r\n\r                                                                                                                      // 153\n            // Inv swap 2nd and 4th rows\r                                                                              // 154\n            var t = M[offset + 1];\r                                                                                    // 155\n            M[offset + 1] = M[offset + 3];\r                                                                            // 156\n            M[offset + 3] = t;\r                                                                                        // 157\n        },\r                                                                                                            // 158\n\r                                                                                                                      // 159\n        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\r          // 160\n            // Shortcut\r                                                                                               // 161\n            var nRounds = this._nRounds;\r                                                                              // 162\n\r                                                                                                                      // 163\n            // Get input, add round key\r                                                                               // 164\n            var s0 = M[offset]     ^ keySchedule[0];\r                                                                  // 165\n            var s1 = M[offset + 1] ^ keySchedule[1];\r                                                                  // 166\n            var s2 = M[offset + 2] ^ keySchedule[2];\r                                                                  // 167\n            var s3 = M[offset + 3] ^ keySchedule[3];\r                                                                  // 168\n\r                                                                                                                      // 169\n            // Key schedule row counter\r                                                                               // 170\n            var ksRow = 4;\r                                                                                            // 171\n\r                                                                                                                      // 172\n            // Rounds\r                                                                                                 // 173\n            for (var round = 1; round < nRounds; round++) {\r                                                           // 174\n                // Shift rows, sub bytes, mix columns, add round key\r                                                  // 175\n                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\r\n                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\r\n                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\r\n                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\r\n\r                                                                                                                      // 180\n                // Update state\r                                                                                       // 181\n                s0 = t0;\r                                                                                              // 182\n                s1 = t1;\r                                                                                              // 183\n                s2 = t2;\r                                                                                              // 184\n                s3 = t3;\r                                                                                              // 185\n            }\r                                                                                                         // 186\n\r                                                                                                                      // 187\n            // Shift rows, sub bytes, add round key\r                                                                   // 188\n            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\r\n            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\r\n            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\r\n            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\r\n\r                                                                                                                      // 193\n            // Set output\r                                                                                             // 194\n            M[offset]     = t0;\r                                                                                       // 195\n            M[offset + 1] = t1;\r                                                                                       // 196\n            M[offset + 2] = t2;\r                                                                                       // 197\n            M[offset + 3] = t3;\r                                                                                       // 198\n        },\r                                                                                                            // 199\n\r                                                                                                                      // 200\n        keySize: 256/32\r                                                                                               // 201\n    });\r                                                                                                               // 202\n\r                                                                                                                      // 203\n    /**\r                                                                                                               // 204\n     * Shortcut functions to the cipher's object interface.\r                                                           // 205\n     *\r                                                                                                                // 206\n     * @example\r                                                                                                       // 207\n     *\r                                                                                                                // 208\n     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\r                                                  // 209\n     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\r                                               // 210\n     */\r                                                                                                               // 211\n    C.AES = BlockCipher._createHelper(AES);\r                                                                           // 212\n}());\r                                                                                                                 // 213\n                                                                                                                       // 214\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n///////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"jparker:crypto-aes\");\n\n})();\n","servePath":"/packages/jparker_crypto-aes.js"}]